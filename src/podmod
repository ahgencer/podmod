#!/bin/sh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

set -e

readonly ROOTDIR=$(cd -P -- "$(dirname -- "$(command -v -- "$0")")/../" && pwd -P)

###################
# Defaults
###################

readonly D_CONFIG_PATH="/etc/podmod.conf"
readonly D_KERNEL_VERSION=$(uname -r)

readonly D_MODULES_DIR="$ROOTDIR/lib/modules"

###################
# Functions
###################

# dependencies()
# Prints a newline-separated list of command dependencies of this script.
dependencies() {
  cat <<EOF
podman
EOF
}

# die(STATUS, MESSAGE)
# Prints MESSAGE to stderr and exits with the error code STATUS.
die() {
  # Validate function arguments
  if [ $# -ne 2 ]; then
    die 200 "Invalid number of arguments to die()"
  fi

  if ! is_int "$1"; then
    die 200 "First argument of die() must be an integer. '$1' given"
  fi

  # Print message and exit
  echo >&2 "$(me): $2"
  exit "$1"
}

# is_int(NUM)
# Returns true if NUM is an integer
is_int() {
  [ "$1" -eq "$1" ] 2>/dev/null
}

# me()
# Prints the basename of this script.
me() {
  basename "$0"
}

# usage()
# Prints the command usage to stdout.
usage() {
  cat <<EOF

$(version): Containerized build system for kernel modules on Fedora.

Builds a kernel module from source inside a Podman container.
Targeted for Fedora Silverblue / Kinoite, but also works for other editions.

Note: This program must be executed with root privileges.

Usage: $(me) -m <MODULE> [OPTIONS] <COMMAND>

Commands:

    build   Build the kernel module.
    load    Load the kernel module. The module must already be built for this.
    unload  Unload the kernel module.

Options:

    -c, --config FILE             Use FILE as configuration. Default: ${D_CONFIG_PATH}
    -h, --help                    Show help and quit.
    -k, --kernel-version VERSION  Target the kernel version VERSION. Defaults to the current running kernel.
    -m, --module MODULE           Work on the module MODULE. Required.
    -V, --version                 Show version and quit.

EOF
}

# version()
# Prints the current program version to stdout.
version() {
  echo "$(me) v0.2.1"
}

###################
# Commands
###################

# cmd_build()
# Builds the kernel module as a container image.
cmd_build() {
  # Check for existing image and build if not found
  if podman image exists "$image:$tag"; then
    die 3 "Image already exists"
  fi

  podman build -t "$image:$tag" \
    --build-arg ARCH="$(uname -p)" \
    --build-arg KERNEL_VERSION="$kernel_version" \
    --build-arg MODULE_SHA256="$module_sha256" \
    --build-arg MODULE_VERSION="$module_version" \
    --build-arg UPSTREAM="$upstream" \
    "$MODULES_DIR/$module"
}

# cmd_load()
# Runs insmod(8) on the module inside a pre-built container image.
# Fails if the image is not found on the system.
cmd_load() {
  # Fail if module is already loaded
  if lsmod | grep "$module" >/dev/null; then
    die 3 "Module is already loaded"
  fi

  # Ensure module is built
  if ! podman image exists "$image:$tag"; then
    die 3 "Module is not built"
  fi

  # Load module from inside container image
  podman run --rm --privileged "$image:$tag" \
    insmod "/usr/lib/modules/$kernel_version/extra/$module.ko"
}

# cmd_unload()
# Runs rmmod(8) to unload the kernel module.
cmd_unload() {
  # Fail if module is not loaded
  if ! lsmod | grep "$module" >/dev/null; then
    die 3 "Module is not loaded"
  fi

  # Unload module
  rmmod "$module"
}

###################
# Main
###################

# Convert long arguments into short forms
for arg in "$@"; do
  case "$arg" in
  --config) set -- "$@" "-c" ;;
  --help) set -- "$@" "-h" ;;
  --kernel-version) set -- "$@" "-k" ;;
  --module) set -- "$@" "-m" ;;
  --version) set -- "$@" "-V" ;;
  *) set -- "$@" "$arg" ;;
  esac

  shift
done

# Process short arguments
while getopts ":c:hk:m:V" opt; do
  case $opt in
  c) configpath="$OPTARG" ;;
  h)
    usage
    exit 0
    ;;
  k) kernel_version="$OPTARG" ;;
  m) module="$OPTARG" ;;
  V)
    version
    exit 0
    ;;
  *)
    die 1 "Invalid option"
    ;;
  esac
done

# Shift arguments that were already handled by getopts
shift $((OPTIND - 1))

# Fallback to defaults for unset arguments
if [ -z ${configpath+x} ]; then configpath=$D_CONFIG_PATH; fi
if [ -z ${kernel_version+x} ]; then kernel_version=$D_KERNEL_VERSION; fi
if [ -z ${module+x} ]; then die 1 "Missing required option -m"; fi

# Ensure dependencies are found
dependencies | while IFS= read -r dependency; do
  command -v "$dependency" >/dev/null 2>&1 || die 2 "Dependency '$dependency' not found in \$PATH"
done

# Ensure script is run as root
if [ "$(id -u)" -ne 0 ]; then
  die 1 "Must be run as root"
fi

# $1 must be the command at this point
# Fail if no more arguments given
if [ $# -ne 1 ]; then
  die 1 "No command given"
fi

command=$1
shift

# Parse configuration file
if [ -f "$configpath" ]; then
  # TODO: Don't source configuration file as shell script
  . "$configpath"
fi

# Fallback to defaults for unset configuration
if [ -z ${MODULES_DIR+x} ]; then MODULES_DIR=$D_MODULES_DIR; fi

# Ensure module is supported
if [ ! -d "$MODULES_DIR" ]; then
  die 1 "Module is not supported"
fi

# Source module manifest
MANIFEST_PATH="$MODULES_DIR/$module/manifest.sh"

if [ ! -f "$MANIFEST_PATH" ]; then
  die 200 "Manifest file not found"
fi

. "$MANIFEST_PATH"

image="$(me)-$module"
tag="$module_version-$kernel_version"

# Jump to command definition
case $command in
build) cmd_build ;;
load) cmd_load ;;
unload) cmd_unload ;;
*)
  die 1 "Invalid command"
  ;;
esac
